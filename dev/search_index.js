var documenterSearchIndex = {"docs":
[{"location":"","page":"API","title":"API","text":"CurrentModule = BaseExtensions","category":"page"},{"location":"#BaseExtensions.jl","page":"API","title":"BaseExtensions.jl","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"Modules = [BaseExtensions]","category":"page"},{"location":"#BaseExtensions.allzero-Tuple{Any}","page":"API","title":"BaseExtensions.allzero","text":"allzero(a)\n\nCheck if all elements of a are zero.\n\nExamples\n\njulia> a = [1, 2, 0];\n\njulia> allzero(a)\nfalse\n\njulia> a = zeros(2);\n\njulia> allzero(a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.anynonzero-Tuple{Any}","page":"API","title":"BaseExtensions.anynonzero","text":"anynonzero(a)\n\nCheck if a contains any non-zero element.\n\nExamples\n\njulia> a = [1, 2, 0];\n\njulia> anynonzero(a)\ntrue\n\njulia> a = zeros(2);\n\njulia> anynonzero(a)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.flipdims-Tuple{Any}","page":"API","title":"BaseExtensions.flipdims","text":"flipdims(A)\n\nPermute A so that the sequence of axes is reversed. For 2D arrays this is an eager transpose. The operation is not recursive.\n\nExamples\n\njulia> A = reshape(collect(1:8), 2, 4)\n2×4 Array{Int64,2}:\n 1  3  5  7\n 2  4  6  8\n\njulia> B = flipdims(A)\n4×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n 7  8\n\njulia> A = reshape(collect(1:8), 2, 2, 2)\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> flipdims(A)\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 5  7\n\n[:, :, 2] =\n 2  4\n 6  8\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.realtype-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T","page":"API","title":"BaseExtensions.realtype","text":"realtype(::Complex)\nrealtype(::Type{<:Complex})\n\nReturn the type of the real and imaginary parts of a Complex number.\n\nExamples\n\njulia> realtype(ComplexF64(2,2))\nFloat64\n\njulia> realtype(ComplexF32(2,2))\nFloat32\n\njulia> realtype(ComplexF32)\nFloat32\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.reinterpretcomplex-Tuple{AbstractArray{var\"#s12\",N} where N where var\"#s12\"<:Real}","page":"API","title":"BaseExtensions.reinterpretcomplex","text":"reinterpretcomplex(arr::AbstractArray{<:Real})\n\nReinterpret a Real array as a Complex one assuming that the real and imaginary parts are laid out consecutively.\n\nExamples\n\njulia> a = [1, 2, 3, 4];\n\njulia> reinterpretcomplex(a)\n2-element reinterpret(Complex{Int64}, ::Array{Int64,1}):\n 1 + 2im\n 3 + 4im\n\nSee also: reinterpretreal\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.reinterpretreal-Tuple{AbstractArray{var\"#s13\",N} where N where var\"#s13\"<:Complex}","page":"API","title":"BaseExtensions.reinterpretreal","text":"reinterpretreal(arr::AbstractArray{<:Complex})\n\nReinterpret a Complex array as a Real one containing the real and imaginary parts.\n\nExamples\n\njulia> a = [1 + 3im, 2+ 4im]\n2-element Array{Complex{Int64},1}:\n 1 + 3im\n 2 + 4im\n\njulia> reinterpretreal(a)\n4-element reinterpret(Int64, ::Array{Complex{Int64},1}):\n 1\n 3\n 2\n 4\n\nSee also: reinterpretcomplex\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.squeeze-Tuple{Any}","page":"API","title":"BaseExtensions.squeeze","text":"squeeze(A)\n\nRemove dimensions from A that have size(A, dim) == 1.  Returns a view that shares the underlying data with A.\n\nExamples\n\njulia> A = reshape(collect(1:4), 1, 4)\n1×4 Array{Int64,2}:\n 1  2  3  4\n\njulia> B = squeeze(A)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.zero!-Tuple{AbstractArray}","page":"API","title":"BaseExtensions.zero!","text":"zero!(a::AbstractArray)\n\nSet all elements of an AbstractArray to zero.\n\nExamples\n\njulia> a = [1, 2];\n\njulia> zero!(a);\n\njulia> a\n2-element Array{Int64,1}:\n 0\n 0\n\n\n\n\n\n","category":"method"}]
}
