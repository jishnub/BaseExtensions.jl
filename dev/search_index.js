var documenterSearchIndex = {"docs":
[{"location":"","page":"API","title":"API","text":"CurrentModule = BaseExtensions","category":"page"},{"location":"#BaseExtensions.jl","page":"API","title":"BaseExtensions.jl","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"Modules = [BaseExtensions]","category":"page"},{"location":"#BaseExtensions.allzero-Tuple{Any}","page":"API","title":"BaseExtensions.allzero","text":"allzero(a)\n\nCheck if all elements of a are zero.\n\nExamples\n\njulia> a = [1, 2, 0];\n\njulia> allzero(a)\nfalse\n\njulia> a = zeros(2);\n\njulia> allzero(a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.anynonzero-Tuple{Any}","page":"API","title":"BaseExtensions.anynonzero","text":"anynonzero(a)\n\nCheck if a contains any non-zero element.\n\nExamples\n\njulia> a = [1, 2, 0];\n\njulia> anynonzero(a)\ntrue\n\njulia> a = zeros(2);\n\njulia> anynonzero(a)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.fillcopy!-Tuple{Any,Any}","page":"API","title":"BaseExtensions.fillcopy!","text":"fillcopy!(A, x)\n\nFill A with shallow copies of x. As in copy, only the outer container of x is copied.\n\nExamples\n\njulia> A = Vector{Vector{Vector{Int}}}(undef, 3);\n\njulia> fillcopy!(A, [[1,2], [1, 2,3]])\n3-element Array{Array{Array{Int64,1},1},1}:\n [[1, 2], [1, 2, 3]]\n [[1, 2], [1, 2, 3]]\n [[1, 2], [1, 2, 3]]\n\njulia> A[1][1] === A[2][1]\ntrue\n\njulia> A[1][1] .= 4:5;\n\njulia> A\n3-element Array{Array{Array{Int64,1},1},1}:\n [[4, 5], [1, 2, 3]]\n [[4, 5], [1, 2, 3]]\n [[4, 5], [1, 2, 3]]\n\nSee also: filldeepcopy!\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.fillcopy-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"BaseExtensions.fillcopy","text":"fillcopy(x, dims...)\n\nCreate an array filled with shallow copies of x, where the dimensions or indices of the array is  specfied through the keyword dims. As in copy, only the outer container of x is copied.\n\nUnlike fill, returns an array where each element is unique. \n\nExamples\n\njulia> A = fillcopy(ones(2), 2, 2)\n2×2 Array{Array{Float64,1},2}:\n [1.0, 1.0]  [1.0, 1.0]\n [1.0, 1.0]  [1.0, 1.0]\n\njulia> A[1,1] === A[2,2]\nfalse\n\njulia> A[1,1] .= 2;\n\njulia> A\n2×2 Array{Array{Float64,1},2}:\n [2.0, 2.0]  [1.0, 1.0]\n [1.0, 1.0]  [1.0, 1.0]\n\njulia> B = fillcopy(A, 2)\n2-element Array{Array{Array{Float64,1},2},1}:\n [[2.0, 2.0] [1.0, 1.0]; [1.0, 1.0] [1.0, 1.0]]\n [[2.0, 2.0] [1.0, 1.0]; [1.0, 1.0] [1.0, 1.0]]\n\njulia> B[2] === B[1]\nfalse\n\njulia> B[2][1] === B[1][1]\ntrue\n\nSee also: filldeepcopy\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.filldeepcopy!-Tuple{Any,Any}","page":"API","title":"BaseExtensions.filldeepcopy!","text":"filldeepcopy!(A, x)\n\nFill A with deep copies of x. The operation is recursive and each element in A will be  completely unique in identity, albeit equal to x in value.\n\nExamples\n\njulia> A = Vector{Vector{Vector{Int}}}(undef, 3);\n\njulia> filldeepcopy!(A, [[1,2], [1, 2,3]])\n3-element Array{Array{Array{Int64,1},1},1}:\n [[1, 2], [1, 2, 3]]\n [[1, 2], [1, 2, 3]]\n [[1, 2], [1, 2, 3]]\n\njulia> A[1][1] === A[2][1]\nfalse\n\njulia> A[1][1] .= 4:5;\n\njulia> A\n3-element Array{Array{Array{Int64,1},1},1}:\n [[4, 5], [1, 2, 3]]\n [[1, 2], [1, 2, 3]]\n [[1, 2], [1, 2, 3]]\n\nSee also: fillcopy!\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.filldeepcopy-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"BaseExtensions.filldeepcopy","text":"filldeepcopy(x, dims...)\n\nCreate an array filled with deep copies of x, where the dimensions or indices of the array is  specfied through the keyword dims. As in deepcopy, the copy operation is recursive, and each element  in the returned array will be completely unique in identity, albeit equal to x in value.\n\nExamples\n\njulia> A = filldeepcopy(ones(2), 2, 2)\n2×2 Array{Array{Float64,1},2}:\n [1.0, 1.0]  [1.0, 1.0]\n [1.0, 1.0]  [1.0, 1.0]\n\njulia> A[1,1] === A[2,2]\nfalse\n\njulia> A[1,1] .= 2;\n\njulia> A\n2×2 Array{Array{Float64,1},2}:\n [2.0, 2.0]  [1.0, 1.0]\n [1.0, 1.0]  [1.0, 1.0]\n\njulia> B = filldeepcopy(A, 2)\n2-element Array{Array{Array{Float64,1},2},1}:\n [[2.0, 2.0] [1.0, 1.0]; [1.0, 1.0] [1.0, 1.0]]\n [[2.0, 2.0] [1.0, 1.0]; [1.0, 1.0] [1.0, 1.0]]\n\njulia> B[2] === B[1]\nfalse\n\njulia> B[2][1] === B[1][1]\nfalse\n\nSee also: fillcopy\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.flipdims-Tuple{Any}","page":"API","title":"BaseExtensions.flipdims","text":"flipdims(A)\n\nPermute A so that the sequence of axes is reversed. For 2D arrays this is an eager transpose. The operation is not recursive.\n\nExamples\n\njulia> A = reshape(collect(1:8), 2, 4)\n2×4 Array{Int64,2}:\n 1  3  5  7\n 2  4  6  8\n\njulia> B = flipdims(A)\n4×2 Array{Int64,2}:\n 1  2\n 3  4\n 5  6\n 7  8\n\njulia> A = reshape(collect(1:8), 2, 2, 2)\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 5  7\n 6  8\n\njulia> flipdims(A)\n2×2×2 Array{Int64,3}:\n[:, :, 1] =\n 1  3\n 5  7\n\n[:, :, 2] =\n 2  4\n 6  8\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.realtype-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T","page":"API","title":"BaseExtensions.realtype","text":"realtype(::Complex)\nrealtype(::Type{<:Complex})\n\nReturn the type of the real and imaginary parts of a Complex number.\n\nExamples\n\njulia> realtype(ComplexF64(2,2))\nFloat64\n\njulia> realtype(ComplexF32(2,2))\nFloat32\n\njulia> realtype(ComplexF32)\nFloat32\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.reinterpretcomplex-Tuple{AbstractArray{var\"#s12\",N} where N where var\"#s12\"<:Real}","page":"API","title":"BaseExtensions.reinterpretcomplex","text":"reinterpretcomplex(arr::AbstractArray{<:Real})\n\nReinterpret a Real array as a Complex one assuming that the real and imaginary parts are laid out consecutively.\n\nExamples\n\njulia> a = [1, 2, 3, 4];\n\njulia> reinterpretcomplex(a)\n2-element reinterpret(Complex{Int64}, ::Array{Int64,1}):\n 1 + 2im\n 3 + 4im\n\nSee also: reinterpretreal\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.reinterpretreal-Tuple{AbstractArray{var\"#s13\",N} where N where var\"#s13\"<:Complex}","page":"API","title":"BaseExtensions.reinterpretreal","text":"reinterpretreal(arr::AbstractArray{<:Complex})\n\nReinterpret a Complex array as a Real one containing the real and imaginary parts.\n\nExamples\n\njulia> a = [1 + 3im, 2+ 4im]\n2-element Array{Complex{Int64},1}:\n 1 + 3im\n 2 + 4im\n\njulia> reinterpretreal(a)\n4-element reinterpret(Int64, ::Array{Complex{Int64},1}):\n 1\n 3\n 2\n 4\n\nSee also: reinterpretcomplex\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.squeeze-Tuple{Any}","page":"API","title":"BaseExtensions.squeeze","text":"squeeze(A)\n\nRemove dimensions from A that have size(A, dim) == 1.  Returns a view that shares the underlying data with A.\n\nExamples\n\njulia> A = reshape(collect(1:4), 1, 4)\n1×4 Array{Int64,2}:\n 1  2  3  4\n\njulia> B = squeeze(A)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"#BaseExtensions.zero!-Tuple{AbstractArray}","page":"API","title":"BaseExtensions.zero!","text":"zero!(a::AbstractArray)\n\nSet all elements of an AbstractArray to zero.\n\nExamples\n\njulia> a = [1, 2];\n\njulia> zero!(a);\n\njulia> a\n2-element Array{Int64,1}:\n 0\n 0\n\n\n\n\n\n","category":"method"}]
}
